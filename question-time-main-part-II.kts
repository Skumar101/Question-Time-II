import khoury.*
import kotlin.math.*






data class Question(val q: String, val a: String)
data class QuestionBank(val name: String, val questions: List<Question>)


// Pt2 of Question Time
// Step 1
data class TaggedQuestion(
    val question: String,
    val answer: String,
    val tags: List<String>
) { 
    fun taggedAs(tag: String): Boolean {
        return tags.contains(tag)
    }
    // Checks if a given tag is present in the question's tags
    
    fun format(): String {
        return "$question|$answer|${tags.joinToString(",")}"
    }
    // Formats the question, answer, and tags into a single string with a specific format.
}






// Step 2
// Converts a formatted string to an object TaggedQuestion
fun stringToTaggedQuestion(str: String): TaggedQuestion {
    val parts = str.split("|")
    val question = parts[0]
    val answer = parts[1]
    val tags = parts[2].split(",").map { it.trim() }
    return TaggedQuestion(question, answer, tags)
}


// Reads a list of TaggedQuestion from a file, converting each line using stringToTaggedQuestion.
fun readTaggedQuestionBank(path: String): List<TaggedQuestion> {
    return if (fileExists(path)) {
        fileReadAsList(path).map { stringToTaggedQuestion(it) }
    } else {
        emptyList()
    }
}


// step 3
/**
* The bank is either completed,
* showing a question or showing
* an answer
*/


/**
* Basic functionality of any question bank
*/
enum class QuestionBankState { COMPLETED, QUESTIONING, ANSWERING }
interface IQuestionBank {
  /**
  * Returns the state of a question bank.
  */
  fun getState(): QuestionBankState
  /**
  * Returns the currently visible text (or null if completed).
  */
  fun getText(): String?
  /**
  * Returns the number of question-answer pairs.
  * (Size does not change when a question is put
  * to the end of the question bank.)
  */
  fun getSize(): Int
  /**
  * Shifts from question to answer. If not QUESTIONING,
  * returns the same IQuestionBank.
  */
  fun show(): IQuestionBank
  /**
  * Shifts from an answer to the next question (or completion).
  * If the current question was answered correctly, it discards
  * it. Otherwise it cycles the question to the end.
  *
  * If not ANSWERING, returns the same IQuestionBank.
  */
  fun next(correct: Boolean): IQuestionBank
}




class ListBasedQuestionBank(private val questions: List<TaggedQuestion>, private val currentState: QuestionBankState = QuestionBankState.QUESTIONING, private val index: Int = 0): IQuestionBank{
  override fun getState(): QuestionBankState = currentState // returns correct state




  override fun getText():String?{ // returns question or answer
    if(questions.isEmpty() || currentState==QuestionBankState.COMPLETED)
      return null
    else if (currentState==QuestionBankState.QUESTIONING)
      return questions[index].question
    else
      return questions[index].answer
    }
  
  override fun getSize():Int = questions.size // returns number of questions




  override fun show():IQuestionBank{ // transitions from question to answer
    return if(currentState == QuestionBankState.QUESTIONING){
      ListBasedQuestionBank(questions, QuestionBankState.ANSWERING, index)
    }else this
  } 




  override fun next(correct: Boolean): IQuestionBank{ // proccess answer and moves to next question
    return if(currentState == QuestionBankState.ANSWERING){
      if(correct){/// got it correct
        if(index +1>=questions.size){
          ListBasedQuestionBank(questions, QuestionBankState.COMPLETED)
        }else{
          val updatedQuestions = questions.toMutableList()
          updatedQuestions.removeAt(index)
          ListBasedQuestionBank(updatedQuestions, QuestionBankState.QUESTIONING, index)
        }
      }else{//got it wrong
        val updatedQuestions = questions.toMutableList()
        updatedQuestions.add(updatedQuestions.removeAt(index))// adds question to end to retry
        ListBasedQuestionBank(updatedQuestions, QuestionBankState.QUESTIONING, index)
      }
    }else this
  }
}


class AutoGeneratedQuestionBank(private val genFunc:(Int) -> TaggedQuestion, private val sequence: List<Int>, private val currentState: QuestionBankState = if(sequence.isEmpty()) QuestionBankState.COMPLETED else QuestionBankState.QUESTIONING): IQuestionBank{
  override fun getState(): QuestionBankState = currentState // returns current state




  override fun getText():String?{ // returns question or answer
    if(currentState==QuestionBankState.COMPLETED)
      return null
    else if (currentState==QuestionBankState.QUESTIONING)
      return genFunc(sequence[0]).question
    else
      return genFunc(sequence[0]).answer


  }




  override fun getSize(): Int = sequence.size // returns number of questioned 


  override fun show(): IQuestionBank = 
        if (currentState == QuestionBankState.QUESTIONING && sequence.isNotEmpty()) {
            AutoGeneratedQuestionBank(genFunc, sequence, QuestionBankState.ANSWERING)
        } else {
            this
        }
  override fun next(correct: Boolean): IQuestionBank = // process answer and move to next question
    takeIf { currentState == QuestionBankState.ANSWERING }?.let { 
        processNextQuestion(correct)
    } ?: this




private fun processNextQuestion(correct: Boolean): IQuestionBank { // updates the sequence of questions based on answer
    val updatedSequence = sequence.drop(1)


    return if(updatedSequence.isEmpty())
    {
      AutoGeneratedQuestionBank(genFunc, updatedSequence, QuestionBankState.COMPLETED)
    }
    else
    {
      AutoGeneratedQuestionBank(genFunc, updatedSequence, QuestionBankState.QUESTIONING)
    }
  }
}
// Step 4
interface IMenuOption {
    fun displayTitle(): String
}


/**
 * A menu option with a single value and name.
 */
data class NamedMenuOption<T>(val option: T, val title: String) : IMenuOption {
    override fun displayTitle(): String = title
}


fun <T : IMenuOption> chooseMenu(options: List<T>): T? {
    while (true) {
        println("Please choose an option:")
        println("0. Quit")
        for ((index, option) in options.withIndex()) {
            println("${index + 1}. ${option.displayTitle()}")
        }


        val input = readLine()?.trim() ?: continue
        
        val choice = input.toIntOrNull()
        if (choice == 0) {
            return null
        } else if (choice != null && choice in 1..options.size) {
            return options[choice - 1]
        }
        
        println("Invalid selection. Please try again.")
    }
}


fun demonstrateChooseMenu() { // displays menu and handles the user's inputs 
    val options = listOf(
        NamedMenuOption(1, "Option 1"),
        NamedMenuOption(2, "Option 2"),
        NamedMenuOption(3, "Option 3")
    )
    val selectedOption = chooseMenu(options)
    if (selectedOption != null) {
        println("You selected: ${selectedOption.displayTitle()}")
    } else {
        println("You chose to quit.")
    }
}
enum class classifierType { NAIVE, KNN }


fun chooseMenu(classifiers: List<String>): classifierType? {
    //Checks if list of classifiers is empty
    if (classifiers.isEmpty()) {
        println("There are no Options")
        return null //Lets user know that there are no options available and return null
    }
    //Keeps prompting user until a valid choice is made 
    while (true) {
        //Displays menu instructions and description of each classifier
        println(
            "Choose You Classifier. Enter 0 to quit.\n The Naive classifier will take yes or no(Anything else will be regarded as a no).\n The KNN classifier will use NLP to determine what you said",
        )
        val map = classifiers.mapIndexed { index, bank -> "${index + 1}. ${classifiers[index]}" }.forEach { println(it) }




        //Prompts user for choice        print("Enter your choice: ")
        val inp = readLine()?.toIntOrNull()


        if (inp != null) {
            if (inp == 0) return null
            else if (inp == 1) return classifierType.NAIVE
            else if (inp == 2) return classifierType.KNN
            else null
        }


        //If the input is invalid, lets user know to try again        
        println("\n Invalid choice. Please try again.")
    }
}


// Step 5
data class LabeledExample<E, L>(val example: E, val label: L)
val dataset: List<LabeledExample<String, Boolean>> = listOf(
    LabeledExample("yes", true),
    LabeledExample("y", true),
    LabeledExample("indeed", true),
    LabeledExample("aye", true),
    LabeledExample("oh yes", true),
    LabeledExample("affirmative", true),
    LabeledExample("roger", true),
    LabeledExample("uh huh", true),
    LabeledExample("true", true),
    /* Some negative examples */
    LabeledExample("no", false),
    LabeledExample("n", false),
    LabeledExample("nope", false),
    LabeledExample("negative", false),
    LabeledExample("nay", false),
    LabeledExample("negatory", false),
    LabeledExample("uh uh", false),
    LabeledExample("absolutely not", false),
    LabeledExample("false", false),
)


//5.1 - Find Closest - finds top item in list


// Top-k function
fun <E> topK(itemList: List<Pair<E, E>>, metrFun: (E, E) -> Int, k: Int): List<Pair<E, Int>> {
    return itemList.map { Pair(it.first, metrFun(it.first, it.second)) }
        .sortedBy { it.second }
        .take(k)
}




//5.2 - Levenshtein Distance - Calculates the Levenshtein distance between two strings.


fun levenshteinDistance(word1: String, word2: String): Int{
    var count = 0
    val diff = abs(word2.length - word1.length)
    count += diff


    var little = ""


    if(word1.length>word2.length)
        little = word2
    else
        little = word1
    
    for(i in 0..little.length-1)
    {
        if(word2[i]!=word1[i])
            count++
    }
    return count
}


//5.3 - k Nearest Neighbor


typealias DistanceFunction<T> = (T, T) -> Int
data class ResultWithVotes<L>(val label: L, val votes: Int)
/**
* Uses k-NN to predict the label for a supplied query
* given a labelled data set and a distance function.
*/
fun <E, L> nnLabel(query: E, dataset: List<LabeledExample<E, L>>, distFn: DistanceFunction<E>, k: Int): ResultWithVotes<L?> {
    // Create a list of pairs (example, query)
    val modData = dataset.map { Pair(it.example, query) }


    // Find top-k closest examples
    val topKResults = topK(modData, distFn, k)


    // Count occurrences of labels among top-k examples
    val labelCounts = topKResults.groupingBy { pair ->
        dataset.find { it.example == pair.first }?.label
    }.eachCount()


    // Find the label with the most votes
    val mostVotes = labelCounts.maxByOrNull { it.value }
    return ResultWithVotes(mostVotes?.key, mostVotes?.value ?: 0)
}


// uses dataset to classify query if no dataset is fast 
fun classifier(query: String, dataset: List<LabeledExample<String,Boolean>>):ResultWithVotes<Boolean?>{
  for(i in dataset){
    if(query == i.example){
      return ResultWithVotes(i.label, 1)
    }
  }




  return nnLabel(query, dataset, ::levenshteinDistance, 3) as ResultWithVotes<Boolean?>
}
fun naiveClassifier( query: String,dataset: List<LabeledExample<String, Boolean>>,): ResultWithVotes<Boolean> {
    if (query.lowercase().startsWith("y")) {
        return ResultWithVotes(true, 1)
    } else {
        return ResultWithVotes(false, 1)
    }
}


// Step 6
//step 6.1
data class StudyQuestionBankResult(val questions: Int,val attempts: Int)
data class StudyQuestionBankState(val bank: IQuestionBank,val results:StudyQuestionBankResult, val dataset: List<LabeledExample<String, Boolean>>, val isDone: Boolean,val classifier: classifierType)


fun stateToText(state: StudyQuestionBankState): String{
    return if (state.bank.getState()!! == QuestionBankState.QUESTIONING){
        state.bank.getText()!!
    }else if (state.bank.getState()!! == QuestionBankState.ANSWERING){
        "The correct answer is ${state.bank.getText()!!}. Did you get it right?"
    }else{
        ""
    }
}


fun transition(state: StudyQuestionBankState, userInput:String): StudyQuestionBankState{
    if(state.bank.getState() != QuestionBankState.COMPLETED){
        if(state.bank.getState()==QuestionBankState.QUESTIONING){
            return StudyQuestionBankState(state.bank.show(), StudyQuestionBankResult(state.results.questions,state.results.attempts + 1),state.dataset, false, state.classifier)
        }else if (state.bank.getState() == QuestionBankState.ANSWERING){
            val correct = if (state.classifier == classifierType.KNN) {
                                            classifier(userInput, state.dataset) //Use KNN for classification 
                                        } else {
                                            naiveClassifier(userInput, state.dataset)
                                        }
            if(correct.label!!){
                return StudyQuestionBankState(state.bank.next(true), state.results, state.dataset, false, state.classifier)
            }else{
                return StudyQuestionBankState(state.bank.next(false), state.results, state.dataset, false, state.classifier)
            }
        }
    }
    return StudyQuestionBankState(state.bank, state.results, state.dataset, true, state.classifier)
}
fun shouldTerminate(state: StudyQuestionBankState): Boolean = state.isDone


fun terminate(state: StudyQuestionBankState): String =
    "Good Job! You answered ${state.results.questions} questions correct in ${state.results.attempts} attempts"


fun studyQuestionBank(state: StudyQuestionBankState) {
    reactConsole(state, ::stateToText, ::transition, ::shouldTerminate, ::terminate)
}


fun study(){
    val q1 = TaggedQuestion("What are we testing?", "Files", listOf("basic", "easy"))


    val q2 = TaggedQuestion("Why are we testing them?", "For class", listOf("questioning", "inquisitive"))


    val q3 = TaggedQuestion("What class is this for?", "Fundies", listOf("relatable", "Alexandros"))


    val questionsGen: (Int,) -> TaggedQuestion = { index -> TaggedQuestion("What is $index cubed?", "${index * index * index}", listOf("Math", "Cubes", "Medium")) }
    val sequence = listOf(4, 7, 8, 10)
    val bank2 = NamedMenuOption(AutoGeneratedQuestionBank(questionsGen, sequence), "Math-Cubes Only")


    


    val sentClassifiers: List<String> = listOf("Naive", "KNN")


    var menu = chooseMenu(listOf(bank1, bank2)) 
    println("\n")
    var classifierMenu = chooseMenu(sentClassifiers)


    while (menu != null && classifierMenu != null) {
        studyQuestionBank(StudyQuestionBankState(menu!!.option, StudyQuestionBankResult(menu!!.option.getSize(), 0), dataset, false,classifierMenu))
        println("")
        menu = chooseMenu(listOf(bank1, bank2))
    }
    println("Congrats, you are done studying")
}


study()